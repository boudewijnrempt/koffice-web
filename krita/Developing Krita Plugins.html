<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
<meta name="Generator" content="KWord HTML Export Filter Version 466447 " />
<title>Developing Krita Plugins.html</title>
</head>
<body>
<p><b>Developing Krita Plugins</b></p>
<p><b>&nbsp;</b></p>
<p>Table of Contents</p>
<p><b>1. Introduction	1</b></p>
<p>1.1. KritaColor	2</p>
<p>1.2. KritaImage	2</p>
<p>1.3. KritaUI	3</p>
<p>1.4. Import/Export filters	3</p>
<p><b>2. Creating plugins	4</b></p>
<p>2.1. Automake (and CMake)	4</p>
<p>2.1.1. Makefile.am	4</p>
<p>2.1.2. Desktop files	5</p>
<p>2.1.3. Boilerplate	5</p>
<p>2.1.4. Registries	6</p>
<p>2.1.5. Plugin versioning	7</p>
<p><b>3. Colorspaces	7</b></p>
<p>3.1. KisChannelInfo	8</p>
<p>3.2. KisCompositeOp	8</p>
<p>3.3. KisColorSpace	8</p>
<p><b>4. Filters	9</b></p>
<p>4.1. Iterators	12</p>
<p>4.2. KisFilterConfiguration	12</p>
<p>4.3. KisFilterConfigurationWidget	13</p>
<p>4.4. Filters conclusion	14</p>
<p><b>5. Tools	14</b></p>
<p>5.1. Tool Conclusions	19</p>
<p><b>6. Paint operations	19</b></p>
<p><b>7. Viewplugins	21</b></p>
<p><b>8. Import/Export filters	22</b></p>
<p>8.1. Import	23</p>
<p>&nbsp;</p>
<h1>Introduction</h1>
<p>Krita is infinitely extensible with plugins. Tools, filters, large chunks of the user interface and even colorspaces are plugins. In fact, Krita recognizes these six types of plugins:</p>
<ul>
<li>colorspaces — these define the channels that constitute a single pixel</li>
<li>tools — anything that is done with a mouse or tablet input device</li>
<li>paint operations — pluggable painting effects for tools</li>
<li>image filters — change all pixels, or just the selected pixels in a layer</li>
<li>viewplugins — extend Krita’s user interface with new dialog boxes, palettes and operations</li>
<li>import/export filters — read and write all kinds of image formats</li>
</ul>
<p>Krita itself consists of three layered libraries and a directory with some common support classes: kritacolor, kritaimage and kritaui. Within Krita, objects can by identified by a KisID, that is the combination of a unique untranslated string (used when saving, for instance) and a translated string for GUI purposes.</p>
<p>A word on compatibility: Krita is still in development. From Krita 1.5 to 1.6 not many API changes are expected, but there may be some. From Krita 1.6 to 2.0 we will move from Qt3 to Qt4, from KDE3 to KDE4, from autmake to cmake: many changes are to be expected. If you develop a plugin for Krita and choose to do so in Krita’s subversion repository, chances are excellent that we’ll help you porting. These changes may also render parts of this document out of date. Always check with the latest api documentation or the header files installed on your system.</p>
<h2>KritaColor</h2>
<p>The first library is kritacolor. This library loads the colorspace plugins.</p>
<ul>
<li>A <b>colorspace plugin </b>should implement the KisColorSpace abstract class or, if the basic capabilities of the new colorspace will be implemented by lcms (http://www.littlecms.com/), extend KisAbstractColorSpace. The kritacolor library could be used from other applications and does not depend on KOffice.</li>
</ul>
<h2>KritaImage</h2>
<p>The libkritaimage library loads the filter and paintop plugins and is responsible for working with image data: changing pixels, compositing and painting. Brushes, palettes, gradients and patterns are also loaded by libkritaimage. It is our stated goal to make libkritaimage independent of KOffice, but we currently share the gradient loading code with KOffice.</p>
<p>It is not easy at the moment to add new types of resources such as brushes, palettes, gradients or patterns to Krita. (Adding new brushes, palettes, gradients and patterns is easy, of course.) Krita follows the guidelines of the Create project (http://create.freedesktop.org/) for these. Adding support for photoshops brush file format needs libkritaimage hacking; adding more gimp brush data files not.</p>
<p>KritaImage loads the following types of plugins:</p>
<ul>
<li><b>Krita filters</b> must extend and implement the abstract class KisFilter, KisFilterConfiguration and possibly KisFilterConfigurationWidget. An example of a filter is Unsharp Mask.</li>
</ul>
<p><b>Paint operations or paintops</b> are the set of operations painting tools suchs as freehand or circle have access to. Examples of paintops are pen, airbrush or eraser. Paintops should extend the KisPaintop base class. Examples of new paintops could be a chalk brush, an oilpaint brush or a complex programmable brush.</p>
<h2>KritaUI</h2>
<p>The libkritaui library loads the tool and viewplugins. This library is a KOffice Part, but also contains a number of widgets that are useful for graphics applications. Maybe we will have to split this library in kritapart and kritaui in the 2.0 release. For now, script writers are not given access to this library and plugin writers are only allowed to use this library when writing tools or viewplugins. KritaUI loads the following types of plugins:</p>
<ul>
<li><b>Tools</b> are derived from KisTool or one of the specialized tool base classes such as KisToolPaint, KisToolNonPaint or KisToolFreehand. A new tool could be a foreground object selection tool. Painting tools (and that includes tools that paint on the selection) can use any paintop to determine the way pixels are changed.</li>
<li><b>Viewplugins </b>are ordinary kparts that use kxmlgui to insinuate themselves into Krita's user interface. Menu options, dialogs, toolbars -- any kind of user interface extension can be a viewplugin. In fact, important functionality like Krita's scripting support is written as a viewplugin.</li>
</ul>
<h2>Import/Export filters</h2>
<p><b>Import/Export filters</b> are KOffice filters, subclasses of KoFilter. Filters read and write image data in any of the myriad image formats in existence. And example of a new Krita import/export filter could be a PDF filter. Filters are loaded by the KOffice libraries.</p>
<h1>Creating plugins</h1>
<p>Plugins are written in C++ and can use all of KDE and Qt and the Krita developer API. Only viewplugins should use the KOffice API. Don’t worry: Krita’s API’s are quite clear and rather extensively documented (for free software) and coding your first filter is really easy.</p>
<p>If you do not want to use C++, you can write scripts in Python or Ruby; that is a different thing altogether, though, and you cannot currently write tools, colorspaces, paintops or import/export filters as scripts. </p>
<p>Krita plugins use KDE's parts mechanism for loading, so the parts documentation at http://developer.kde.org is relevant here, too.</p>
<p>Your distribution should have either installed the relevant header files with Krita itself, or might have split the header files into either a KOffice dev or a Krita dev package. You can find the api documentation for Krita's public API at http://koffice.org/developer/apidocs/krita/html/.</p>
<h2>Automake (and CMake)</h2>
<p>KDE 3.x and thus KOffice 1.5 and 1.6 use automake; KDE 4.0 and KOffice 2.0 use cmake. This tutorial describes the automake way of creating plugins. If I have not updated this manual when we release KOffice 2.0, please remind me to do so.</p>
<p>Plugins are kde modules and should be tagged as such in their Makefile.am. Filters, tools, paintops, colorspaces and import/export filters need .desktop files; viewplugins need a KXMLGui <b>pluginname.rc</b> file in addition. The easiest way to get started is to checkout the krita-plugins project from the koffice subversion repository and use it as the basis for your own project. We intend to prepare a skeleton krita plugin pack for KDevelop, but haven’t had the time to do so yet.</p>
<h3>Makefile.am</h3>
<p>Let's look at the skeleton for a plugin module. First, the Makefile.am. This is what KDE uses to generate the makefile that builds your plugin:</p>
<p><tt>kde_services_DATA = kritaLIBRARYNAME.desktop</tt></p>
<p><tt>&nbsp;</tt></p>
<p><tt>INCLUDES = $(all_includes)</tt></p>
<p><tt>&nbsp;</tt></p>
<p><tt>kritaLIBRARYNAME_la_SOURCES = sourcefile1.cc sourcefile2.cc</tt></p>
<p><tt>&nbsp;</tt></p>
<p><tt>kde_module_LTLIBRARIES = kritaLIBRARYNAME.la</tt></p>
<p><tt>noinst_HEADERS = header1.h header2.h</tt></p>
<p><tt>&nbsp;</tt></p>
<p><tt>kritaLIBRARYNAME_la_LDFLAGS = $(all_libraries) -module $(KDE_PLUGIN)</tt></p>
<p><tt>kritaLIBRARY_la_LIBADD = -lkritacommon</tt></p>
<p><tt>&nbsp;</tt></p>
<p><tt>kritaextensioncolorsfilterse_la_METASOURCES = AUTO</tt></p>
<p>This is the makefile for a filter plugin. Replace LIBRARYNAME with the name of your work, and you're set.</p>
<p>If your plugin is a viewplugin, you will likely also install a .rc file with entries for menubars and toolbars. Likewise, you may need to install cursors and icons. That's all done through the ordinary KDE Makefile.am magic incantantions:</p>
<p><tt>kritarcdir = $(kde_datadir)/krita/kritaplugins</tt></p>
<p><tt><b>kritarc_DATA = LIBRARYNAME.rc</b></tt></p>
<p><tt><b>EXTRA_DIST = $(kritarc_DATA)</b></tt></p>
<p><tt>&nbsp;</tt></p>
<p><tt>kritapics_DATA = \</tt></p>
<p><tt>    bla.png \</tt></p>
<p><tt>    bla_cursor.png</tt></p>
<p><tt>kritapicsdir = $(kde_datadir)/krita/pics</tt></p>
<p>&nbsp;</p>
<h3>Desktop files</h3>
<p>The .desktop file announces the type of plugin:</p>
<p><tt>[Desktop Entry]</tt></p>
<p><tt>Encoding=UTF-8</tt></p>
<p><tt>Icon=</tt></p>
<p><tt>Name=User-visible Name</tt></p>
<p><tt>ServiceTypes=Krita/Filter</tt></p>
<p><tt>Type=Service</tt></p>
<p><tt><b>X-KDE-Library=kritaLIBRARYNAME</b></tt></p>
<p><tt>X-KDE-Version=2</tt></p>
<p>Possible ServiceTypes are:</p>
<ul>
<li>Krita/Filter</li>
<li>Krita/Paintop</li>
<li>Krita/ViewPlugin</li>
<li>Krita/Tool</li>
<li>Krita/ColorSpace</li>
</ul>
<p>File import and export filters use the generic KOffice filter framework and need to be discussed separately. </p>
<h3>Boilerplate</h3>
<p>You also need a bit of boilerplate code that is called by the KDE part framework to instantiate the plugin — a header file and an implementation file.</p>
<p>a header file:</p>
<p><tt>#ifndef TOOL_STAR_H_</tt></p>
<p><tt>#define TOOL_STAR_H_</tt></p>
<p><tt>&nbsp;</tt></p>
<p><tt>#include &lt;kparts/plugin.h&gt;</tt></p>
<p><tt>&nbsp;</tt></p>
<p><tt>/**</tt></p>
<p><tt> * A module that provides a star tool.</tt></p>
<p><tt> */</tt></p>
<p><tt>class ToolStar : public KParts::Plugin</tt></p>
<p><tt>{</tt></p>
<p><tt>    Q_OBJECT</tt></p>
<p><tt>public:</tt></p>
<p><tt>    ToolStar(QObject *parent, const char *name, const QStringList &amp;);</tt></p>
<p><tt>    virtual ~ToolStar();</tt></p>
<p><tt>&nbsp;</tt></p>
<p><tt>};</tt></p>
<p><tt>&nbsp;</tt></p>
<p><tt>#endif // TOOL_STAR_H_</tt></p>
<p><tt>&nbsp;</tt></p>
<p>And an implementation file:</p>
<p><tt>#include &lt;kinstance.h&gt;</tt></p>
<p><tt>#include &lt;kgenericfactory.h&gt;</tt></p>
<p><tt>&nbsp;</tt></p>
<p><tt>#include &lt;kis_tool_registry.h&gt;</tt></p>
<p><tt>&nbsp;</tt></p>
<p><tt>#include &quot;tool_star.h&quot;</tt></p>
<p><tt>#include &quot;kis_tool_star.h&quot;</tt></p>
<p><tt>&nbsp;</tt></p>
<p><tt>&nbsp;</tt></p>
<p><tt>typedef KGenericFactory&lt;ToolStar&gt; ToolStarFactory;</tt></p>
<p><tt>K_EXPORT_COMPONENT_FACTORY( kritatoolstar, ToolStarFactory( &quot;krita&quot; ) )</tt></p>
<p><tt>&nbsp;</tt></p>
<p><tt>&nbsp;</tt></p>
<p><tt>ToolStar::ToolStar(QObject *parent, const char *name, const QStringList &amp;)</tt></p>
<p><tt>    : KParts::Plugin(parent, name)</tt></p>
<p><tt>{</tt></p>
<p><tt>    setInstance(ToolStarFactory::instance());</tt></p>
<p><tt>    if ( parent-&gt;inherits(&quot;KisToolRegistry&quot;) )</tt></p>
<p><tt>    {</tt></p>
<p><tt>        KisToolRegistry * r = dynamic_cast&lt;KisToolRegistry*&gt;( parent );</tt></p>
<p><tt>        r -&gt; add(new KisToolStarFactory());</tt></p>
<p><tt>    }</tt></p>
<p><tt>&nbsp;</tt></p>
<p><tt>}</tt></p>
<p><tt>&nbsp;</tt></p>
<p><tt>ToolStar::~ToolStar()</tt></p>
<p><tt>{</tt></p>
<p><tt>}</tt></p>
<p><tt>&nbsp;</tt></p>
<p><tt>#include &quot;tool_star.moc&quot;</tt></p>
<h3>Registries</h3>
<p>Tools are loaded by the tool registry and register themselves with the tool registry. Plugins like tools, filters and paintops are loaded only once: view plugins are loaded for every view that is created. Note that we register factories, generally speaking. For instance, with tools a new instance of a tool is created for every pointer (mouse, stylus, eraser) for every few. And a new paintop is created whenever a tool gets a mouse-down event.</p>
<p>Filters call the filter registry: </p>
<p><tt>    if (parent-&gt;inherits(&quot;KisFilterRegistry&quot;)) {</tt></p>
<p><tt>        KisFilterRegistry * manager = dynamic_cast&lt;KisFilterRegistry *&gt;(parent);</tt></p>
<p><tt>        manager-&gt;add(new KisFilterInvert());</tt></p>
<p><tt>    }</tt></p>
<p>Paintops the paintop registry:</p>
<p><tt>    if ( parent-&gt;inherits(&quot;KisPaintOpRegistry&quot;) ) {</tt></p>
<p><tt>            KisPaintOpRegistry * r = dynamic_cast&lt;KisPaintOpRegistry*&gt;(parent);</tt></p>
<p><tt>            r -&gt; add ( new KisSmearyOpFactory );</tt></p>
<p><tt>    }</tt></p>
<p>Colorspaces the colorspace registry (with some complications):</p>
<p><tt>    if ( parent-&gt;inherits(&quot;KisColorSpaceFactoryRegistry&quot;) ) {</tt></p>
<p><tt>	KisColorSpaceFactoryRegistry * f = dynamic_cast&lt;KisColorSpaceFactoryRegistry*&gt;(parent);</tt></p>
<p><tt>&nbsp;</tt></p>
<p><tt>        KisProfile *defProfile = new KisProfile(cmsCreate_sRGBProfile());</tt></p>
<p><tt>        f-&gt;addProfile(defProfile);</tt></p>
<p><tt>&nbsp;</tt></p>
<p><tt>        KisColorSpaceFactory * csFactory = new KisRgbColorSpaceFactory();</tt></p>
<p><tt>        f-&gt;add(csFactory);</tt></p>
<p><tt>&nbsp;</tt></p>
<p><tt>        KisColorSpace * colorSpaceRGBA = new KisRgbColorSpace(f, 0);</tt></p>
<p><tt>        KisHistogramProducerFactoryRegistry::instance() -&gt; add(</tt></p>
<p><tt>                new KisBasicHistogramProducerFactory&lt;KisBasicU8HistogramProducer&gt;</tt></p>
<p><tt>                (KisID(&quot;RGB8HISTO&quot;, i18n(&quot;RGB8 Histogram&quot;)), colorSpaceRGBA) );</tt></p>
<p><tt>    }</tt></p>
<p>View plugins don't have to register themselves, <i>and </i>they get access to a KisView object:</p>
<p><tt>    if ( parent-&gt;inherits(&quot;KisView&quot;) )</tt></p>
<p><tt>    {</tt></p>
<p><tt>        setInstance(ShearImageFactory::instance());</tt></p>
<p><tt>        setXMLFile(locate(&quot;data&quot;,&quot;kritaplugins/shearimage.rc&quot;), true);</tt></p>
<p><tt>&nbsp;</tt></p>
<p><tt>        (void) new KAction(i18n(&quot;&amp;Shear Image...&quot;), 0, 0, this, SLOT(slotShearImage()), actionCollection(), &quot;shearimage&quot;);</tt></p>
<p><tt>        (void) new KAction(i18n(&quot;&amp;Shear Layer...&quot;), 0, 0, this, SLOT(slotShearLayer()), actionCollection(), &quot;shearlayer&quot;);</tt></p>
<p><tt>&nbsp;</tt></p>
<p><tt>        m_view = (KisView*) parent;</tt></p>
<p><tt>    }</tt></p>
<p>Remember that this means that a view plugin will be created for every view the user creates: splitting a view means loading all view plugins again.</p>
<h3>Plugin versioning</h3>
<p>Krita 1.5 loads plugins with the  <tt><b>X-KDE-Version=2 </b></tt>set in the .desktop file. Krita 1.6 plugins will probably be binary incompatible with 1.5 plugins and will need the version number 3. Krita 2.0 plugins will need the version number 3. Yes, this is not entirely logical.</p>
<h1>Colorspaces</h1>
<p>Colorspaces implement the KisColorSpace pure virtual class. There are two types of colorspaces: those that can use lcms for transformations between colorspaces, and those that are too weird for lcms to handle. Examples of the first are cmyk, rgb, yuv. An example of the latter is watercolor or wet &amp; sticky. Colorspaces that use lcms can be derived from KisAbstractColorSpace, or of one of the base classes that are specialized for a certain number of bits per channel.</p>
<p>Implementing a colorspace is pretty easy. The general principle is that colorspaces work on a simple array of bytes. The interpretation of these bytes is up to the colorspace. For instance, a pixel in 16-bit GrayA consists of four bytes: two bytes for the gray value and two bytes for the alpha value. You're free to use a struct to work with the memory layout of a pixel in your colorspace implementation, but that representation is not exported. The only way the rest of Krita can know what channels and types of channels your colorspace pixels consist of is through the KisChannelInfo class.</p>
<p>Filters and paintops make use of the rich set of methods offered by KisColorSpace to do their work. In many cases, the default implementation in KisAbstractColorSpace will work, but more slowly than a custom implementation in your own colorspace because KisAbstractColorSpace will convert all pixels to 16-bit L*a*b and back.</p>
<h2>KisChannelInfo</h2>
<p><tt>(http://websvn.kde.org/trunk/koffice/krita/kritacolor/kis_channelinfo.h)</tt></p>
<p>This class defines the channels that make up a single pixel in a particular colorspace. A channel has the following important characteristics:</p>
<ul>
<li>a name for display in the user interface</li>
<li>a position: the byte where the bytes representing this channel start in the pixel.</li>
<li>a type: color, alpha, substance or substrate. Color is plain color, alpha is see-throughishness, substance is a representation of amount of pigment or things like that, substrate is the representation of the canvas. (Note that this may be refactored at the drop of a hat.)</li>
<li>a valuetype: byte, short, integer, float — or other.</li>
<li>size: the number of bytes this channel takes</li>
<li>color: a QColor representation of this channel for user interface visualization, for instance in histograms.</li>
<li>an abbreviaton for use in the GUI when there’s not much space</li>
</ul>
<h2>KisCompositeOp</h2>
<p>As per original (XXX: link) Porter-Duff, there are many ways of combining pixels to get a new color. The KisCompositeOp class defines most of them: this set is not easily extensible except by hacking the kritacolor library. </p>
<p>A colorspace plugin can support any subset of these possible composition operations, but the set must always include &quot;OVER&quot; (same as &quot;NORMAL&quot;) and &quot;COPY&quot;. The rest are more or less optional, although more is better, of course.</p>
<h2>KisColorSpace</h2>
<p>The methods in the KisColorSpace pure virtual classs can be divided into a number of groups: conversion, identification and manipulation. </p>
<p>All classes must be able to convert a pixel from and to 8 bit RGB (i.e., a QColor), and preferably also to and from 16 bit L*a*b. Additionally, there is a method to convert to any colorspace from the current colorspace.</p>
<p>Colorspaces are described by the KisChannelInfo vector, number of channels, number of bytes in a single pixel, whether it supports High Dynamic Range images and more.</p>
<p>Manipulation is for instance the combining of two pixels in a new pixel: bitBlt, darkening or convolving of pixels.</p>
<p>Please consult the api documentation (XXX: link) for a full description of all methods you need to implement in a colorspace.</p>
<p>KisAbstractColorSpace implements many of the virtual methods of KisColorSpace using functions from the lcms library. On top of KisAbstractColorSpace there are base colorspace classes for 8 and 16 bit integer and 16 and 32 bit float colorspaces that define common operations to move between bit depths.</p>
<h1>Filters</h1>
<p>Filters are plugins that examine the pixels in a layer and them make changes to them. Although Krita uses an efficient tiled memory backend to store pixels, filter writers do not have to bother with that. When writing a filter plugin for the Java imaging api, Photoshop or the Gimp you need to take care of tile edges and &quot;cobble&quot; tiles together: krita hides that implementation detail1.</p>
<p>Krita uses iterators to read and write pixel values. Alternatively, you can read a block of pixels into a memory buffer, mess with it and then write it back as a block. But that is not necessarily more efficient, it may even be slower than using the iterators; it may just be more convenient. See the API documentation: XXX.</p>
<p>Krita images are composed of layers, of which there are currently four kinds: paint layers, group layers, adjustment layers (that contain a filter that is applied dynamically to layers below the adjustment layer) and part layers. Filters always operate on paint layers. Paint layers contain paint devices, of the class KisPaintDevice (XXX: api dox). A paint device in its turn gives access to the actual pixels.</p>
<p>PaintDevices are generally passed around wrapped in shared pointers. A shared pointer keeps track of in how many places the paint device is currently used and deletes the paint device when it is no longer used anywhere. You recognize the shared pointer version of a paint device through its SP suffix. Just remember that you never had to explicitly delete a KisPaintDeviceSP.</p>
<p>Let's examine a very simple filter, one that inverts every pixel. The code for this filter is in the <tt>koffice/krita/plugins/filters/example </tt>directory. </p>
<p>The main method is </p>
<p><tt>KisFilterInvert::process(KisPaintDeviceSP src, KisPaintDeviceSP dst,</tt></p>
<p><tt>                         KisFilterConfiguration* /*config*/, const QRect&amp; rect).</tt></p>
<p>The function gets passed two paint devices, a configuration object (which is not used in this simple filter) and a rect. The rect describes the area of the paint device which the filter should act on. This area is described by integers, which means no sub-pixel accuracy.</p>
<p>The src paint device is for reading from, the dst paint device for writing to. These parameters may point to the same actual paint device, or be two different paint devices. (Note: this may change to only one paint device in the future.)</p>
<p>Now, let's look at the code line by line:</p>
<p><tt>void KisFilterInvert::process(KisPaintDeviceSP src, KisPaintDeviceSP dst,</tt></p>
<p><tt>                              KisFilterConfiguration* /*config*/, const QRect&amp; rect)</tt></p>
<p><tt>{</tt></p>
<p><tt>    Q_ASSERT(src != 0);</tt></p>
<p><tt>    Q_ASSERT(dst != 0);</tt></p>
<p><tt>&nbsp;</tt></p>
<p><tt>    KisRectIteratorPixel srcIt = src-&gt;createRectIterator(rect.x(), rect.y(), rect.width(), rect.height(), false); <b>(1)</b></tt></p>
<p><tt>    KisRectIteratorPixel dstIt = dst-&gt;createRectIterator(rect.x(), rect.y(), rect.width(), rect.height(), true ); <b>(2)</b></tt></p>
<p><tt>&nbsp;</tt></p>
<p><tt>    int pixelsProcessed = 0;</tt></p>
<p><tt>    setProgressTotalSteps(rect.width() * rect.height());</tt></p>
<p><tt>&nbsp;</tt></p>
<p><tt>    KisColorSpace * cs = src-&gt;colorSpace();</tt></p>
<p><tt>    Q_INT32 psize = cs-&gt;pixelSize();</tt></p>
<p><tt>&nbsp;</tt></p>
<p><tt>    while( ! srcIt.isDone() )</tt></p>
<p><tt>    {</tt></p>
<p><tt>        if(srcIt.isSelected())<b>(3)</b></tt></p>
<p><tt>        {</tt></p>
<p><tt>            memcpy(dstIt.rawData(), srcIt.oldRawData(), psize);<b>(4)</b></tt></p>
<p><tt>&nbsp;</tt></p>
<p><tt>            cs-&gt;invertColor( dstIt.rawData(), 1);<b>(5)</b></tt></p>
<p><tt>        }</tt></p>
<p><tt>        setProgress(++pixelsProcessed);</tt></p>
<p><tt>        ++srcIt;</tt></p>
<p><tt>        ++dstIt;</tt></p>
<p><tt>    }</tt></p>
<p><tt>    setProgressDone(); // Must be called even if you don't really support progression</tt></p>
<p><tt>}</tt></p>
<p>&nbsp;</p>
<p><b>(1)</b> This creates an iterator to read the existing pixels. Krita has three types of iterators: horizontal, vertical and rectangular. The rect iterator takes the most efficient path through the image data, but does not guarantee anything about the location of the next pixel it returns. That means that you cannot be sure that the pixel you will retrieve next will be adjacent to the pixel you just got. The horizontal and vertical line iterators do guarantee the location of the pixels they return.</p>
<p><b>(2) </b>We create the destination iterator with the write setting to true. This means that if the destination paint device is smaller than the rect we write, it will automatically be enlarged to fit every pixel we iterate over.</p>
<p>Note that we've got a potential bug here: if dst and src are not the same device, then it is quite possible that the pixels returned by the iterators do not correspond. For every position in the iterator, src may be, for example, at 165,200, while dst could be at 20,8 -- and therefore the copy we perform below may distort the image...</p>
<p><b>(3) </b>Want to know if a pixel is selected? That's easy -- use the <tt>isSelected</tt> method. But selectedness is not a binary property of a pixel, a pixel can be half selected, barely selected or almost completely selected. That value you can also got from the iterator. Selections are actually a mask paint device with a range between 0 and 255, where 0 is completely unselected and 255 completely selected. The iterator has two methods: isSelected() and selectedNess(). The first returns true if a pixel is selected to any extent (i.e., the mask value is greater than 1), the other returns the maskvalue.</p>
<p><b>(4) </b>As noted above, this memcpy is a big bad bug... rawData() returns the array of bytes which is the current state of the pixel; oldRawData() returns the array of bytes as it was before we created the iterator. However, we may be copying the wrong pixel here. In actual practice, that won't happen too often, unless dst already exists and isn't aligned with src.</p>
<p><b>(5) </b>But this is correct: instead of figuring out which byte represents which channel, we use a function supplied by all colorspaces to invert the current pixel. The colorspaces have a lot of pixel operations you can make use of.</p>
<p>This is not all there is to creating a filter. Filters have two other important components: a configuration object and a configuration widget. The two interact closely. The configuration widget creates a configuration object, but can also be filled from a pre-existing configuration object. Configuration objects can represtent themselves as XML and can be created from XML. That is what makes adjustment layers possible.</p>
<h2>Iterators</h2>
<p>There are three types of iterators: </p>
<ul>
<li>Horizontal lines</li>
<li>Vertical lines</li>
<li>Rectangular iterors</li>
</ul>
<p>The horizontal and vertical line iterators have a method to move the iterator to the next row or column:nextRow() and nextCol(). Using these is much faster than creating a new iterator for every line or column. </p>
<p>Iterators are thread-safe in Krita, so it is possible to divide the work over multiple threads. However, future versions of Krita will use the <tt>supportsThreading()</tt> method to determine whether your filter can be applied to chunks of the image (i.e., all pixels modified independently, instead of changed by some value determined from an examination of all pixels in the image) and automatically thread the execution your filter.</p>
<h2>KisFilterConfiguration</h2>
<p>KisFilterConfiguration is a structure that is used to save filter settings to disk, for instance for adjustment layers. The scripting plugin uses the property map that’s at the back of KisFilterConfigaration to make it possible to script filters. Filters can provide a custom widget that Krita will show in the filters gallery, the filter preview dialog or the tool option tab of the paint-with-filters tool. </p>
<p>An example, taken from the oilpaint effect filter:</p>
<p><tt>class KisOilPaintFilterConfiguration : public KisFilterConfiguration</tt></p>
<p><tt>{</tt></p>
<p><tt>&nbsp;</tt></p>
<p><tt>public:</tt></p>
<p><tt>&nbsp;</tt></p>
<p><tt>    KisOilPaintFilterConfiguration(Q_UINT32 brushSize, Q_UINT32 smooth)</tt></p>
<p><tt>        : KisFilterConfiguration( &quot;oilpaint&quot;, 1 )</tt></p>
<p><tt>        {</tt></p>
<p><tt>            setProperty(&quot;brushSize&quot;, brushSize);</tt></p>
<p><tt>            setProperty(&quot;smooth&quot;, smooth);</tt></p>
<p><tt>        };</tt></p>
<p><tt>public:</tt></p>
<p><tt>&nbsp;</tt></p>
<p><tt>    inline Q_UINT32 brushSize() { return getInt(&quot;brushSize&quot;); };</tt></p>
<p><tt>    inline Q_UINT32 smooth() {return getInt(&quot;smooth&quot;); };</tt></p>
<p><tt>&nbsp;</tt></p>
<p><tt>};</tt></p>
<h2>KisFilterConfigurationWidget</h2>
<p>Most filters can be tweaked by the user. You can create a configuration widget that Krita will use where-ever your filter is used. An example:</p>
<p>&nbsp;</p>
<p><img src="Developing Krita Plugins.html.dir/picture1.png" alt="Pictures/Pictures0.png"/></p>
<p>Note that only the left-hand side of this dialog is your responsibility: Krita takes care of the rest. There are three ways of going about creating an option widget:</p>
<p>* Use Qt Designer to create a widget base, and subclass it for your filter</p>
<p>* Use one of the simple widgets that show a number of sliders for lists of integers, doubles or bools. These are useful if, like the above screenshot, your filter can be configured by a number of integers, doubles or bools. See the api dox for KisMultiIntegerFilterWidget, KisMultiDoubleFilterWidget and KisMultiBoolFilterWidget.</p>
<p>* Hand-code a widget. This is <i>not</i> recommended, and if you do so and want your filter to become part of Krita’s official release, then I’ll ask you to replate your hand-coded widget with a Qt Designer widget.</p>
<p>The oilpaint filter uses the multi integer widget:</p>
<p>&nbsp;</p>
<p><tt>KisFilterConfigWidget * KisOilPaintFilter::createConfigurationWidget(QWidget* parent, KisPaintDeviceSP /*dev*/)</tt></p>
<p><tt>{</tt></p>
<p><tt>    vKisIntegerWidgetParam param;</tt></p>
<p><tt>    param.push_back( KisIntegerWidgetParam( 1, 5, 1, i18n(&quot;Brush size&quot;), &quot;brushSize&quot; ) );</tt></p>
<p><tt>    param.push_back( KisIntegerWidgetParam( 10, 255, 30, i18n(&quot;Smooth&quot;), &quot;smooth&quot; ) );</tt></p>
<p><tt>    return new KisMultiIntegerFilterWidget(parent, id().id().ascii(), id().id().ascii(), param );</tt></p>
<p><tt>}</tt></p>
<p><tt>&nbsp;</tt></p>
<p><tt>KisFilterConfiguration* KisOilPaintFilter::configuration(QWidget* nwidget)</tt></p>
<p><tt>{</tt></p>
<p><tt>    KisMultiIntegerFilterWidget* widget = (KisMultiIntegerFilterWidget*) nwidget;</tt></p>
<p><tt>    if( widget == 0 )</tt></p>
<p><tt>    {</tt></p>
<p><tt>        return new KisOilPaintFilterConfiguration( 1, 30);</tt></p>
<p><tt>    } else {</tt></p>
<p><tt>        return new KisOilPaintFilterConfiguration( widget-&gt;valueAt( 0 ), widget-&gt;valueAt( 1 ) );</tt></p>
<p><tt>    }</tt></p>
<p><tt>}</tt></p>
<p><tt>&nbsp;</tt></p>
<p><tt>std::list&lt;KisFilterConfiguration*&gt; KisOilPaintFilter::listOfExamplesConfiguration(KisPaintDeviceSP )</tt></p>
<p><tt>{</tt></p>
<p><tt>    std::list&lt;KisFilterConfiguration*&gt; list;</tt></p>
<p><tt>    list.insert(list.begin(), new KisOilPaintFilterConfiguration( 1, 30));</tt></p>
<p><tt>    return list;</tt></p>
<p><tt>}</tt></p>
<p>You can see how it works: fill a vector with your integer parameters and create the widget. The <tt>configuration()</tt>method inspects the widget and creates the right filter configuration object, in this case, of course, <tt>KisOilPaintFilterConfiguration</tt>. The listOfExamplesConfiguration (which should be renamed to correct English...) returns a list with example configuration objects for the filters gallery dialog.</p>
<h2>Filters conclusion</h2>
<p>There’s more to coding interesting filters, of course, but with this explanation, the XXX api documentation and access to our source code, you should be able to get started. Don’t hesitate to contact the Krita developers on IRC or on the mailing list. </p>
<h1>Tools</h1>
<p>Tools appear in Krita’s toolbox. This means that there is limited space for new tools — think carefully whether a paint operation isn’t enough for your purposes. Tools can use the mouse/tablet and keyboard in complex ways, which paint operations cannot. This is the reason that Duplicate is a tool, but airbrush a paint operation.</p>
<p>Be careful with static data in your tool: a new instance of your tool is created for every input device: mouse, stylus, eraser, airbrush — whatever.</p>
<p>Tools come divided into logical groups: </p>
<p>* shape drawing tools (circle, rect)</p>
<p>* freehand drawing tools (brush)</p>
<p>* transform tools that mess up the geometry of a layer, </p>
<p>* fill tools (like bucket fill or gradient), </p>
<p>* view tools (that don’t change pixels, but alter the way you view the canvas, such as zoom)</p>
<p>* select tools (that change the selection mask)</p>
<p>The tool interface is described in the api documentation for KisTool (XXX). There are three subclasses: KisToolPaint, KisToolNonPaint and KisToolShape (which is actually a subclass of KisToolPaint) that specialize KisTool for painting tasks (i.e., changing pixels) , non-painting tasks and shape painting tasks.</p>
<p>A tool has an option widget, just like filters. Currently, the option widgets are shown in a tab in a dock window. We may change that to a strip under the main menu (which then replaces the toolbar) for Krita 2.0, but for now, design your option widget to fit in a tab. As always, it’s best to use Qt Designer for the design of the option widget.</p>
<p>A good example of a tool is the star tool:</p>
<p><tt>kis_tool_star.cc       Makefile.am   tool_star_cursor.png  wdg_tool_star.ui</tt></p>
<p><tt>kis_tool_star.h        Makefile.in   tool_star.h           </tt></p>
<p><tt>kritatoolstar.desktop  tool_star.cc  tool_star.png         </tt></p>
<p>As you see, you need two images: one for the cursor and one for the toolbox. Toolstar.cpp is just the plugin loader, similar to what we have seen above. The real meat is in the implementation:</p>
<p><tt>KisToolStar::KisToolStar()</tt></p>
<p><tt>    : KisToolShape(i18n(&quot;Star&quot;)),</tt></p>
<p><tt>      m_dragging (false),</tt></p>
<p><tt>      m_currentImage (0)</tt></p>
<p><tt>{</tt></p>
<p><tt>    setName(&quot;tool_star&quot;);</tt></p>
<p><tt>    setCursor(KisCursor::load(&quot;tool_star_cursor.png&quot;, 6, 6));</tt></p>
<p><tt>    m_innerOuterRatio=40;</tt></p>
<p><tt>    m_vertices=5;</tt></p>
<p><tt>}</tt></p>
<p>The constructor sets the internal name — which is not translated — and the call to the superclass sets the visible name. We also load the cursor image and set a number of variables.</p>
<p><tt>void KisToolStar::update (KisCanvasSubject *subject)</tt></p>
<p><tt>{</tt></p>
<p><tt>    KisToolShape::update (subject);</tt></p>
<p><tt>    if (m_subject)</tt></p>
<p><tt>        m_currentImage = m_subject-&gt;currentImg();</tt></p>
<p><tt>}</tt></p>
<p>The update() method is called when the tool is selected. This is not a KisTool method, but a KisCanvasObserver (XXX) method. Canvas observers are notified whenever something changes in the view, which can be useful for tools.</p>
<p>The following methods (<tt>buttonPress</tt>, <tt>move </tt>and <tt>buttonRelease</tt>) are called by Krita when the input device (mouse, stylus, eraser etc.) is pressed down, moved or released. Note that you also get move events if the mouse button isn’t pressed. The events are not the regular Qt events, but synthetic Krita events because we make use of low-level trickery to get enough events to draw a smooth line. By default, toolkits like Qt (and GTK) drop events if they are too busy to handle them, and we want them all. </p>
<p><tt>void KisToolStar::buttonPress(KisButtonPressEvent *event)</tt></p>
<p><tt>{</tt></p>
<p><tt>    if (m_currentImage &amp;&amp; event-&gt;button() == LeftButton) {</tt></p>
<p><tt>        m_dragging = true;</tt></p>
<p><tt>        m_dragStart = event-&gt;pos();</tt></p>
<p><tt>        m_dragEnd = event-&gt;pos();</tt></p>
<p><tt>        m_vertices = m_optWidget-&gt;verticesSpinBox-&gt;value();</tt></p>
<p><tt>        m_innerOuterRatio = m_optWidget-&gt;ratioSpinBox-&gt;value();</tt></p>
<p><tt>    }</tt></p>
<p><tt>}</tt></p>
<p>&nbsp;</p>
<p><tt>void KisToolStar::move(KisMoveEvent *event)</tt></p>
<p><tt>{</tt></p>
<p><tt>    if (m_dragging) {</tt></p>
<p><tt>        // erase old lines on canvas</tt></p>
<p><tt>        draw(m_dragStart, m_dragEnd);</tt></p>
<p><tt>        // move (alt) or resize star</tt></p>
<p><tt>        if (event-&gt;state() &amp; Qt::AltButton) {</tt></p>
<p><tt>            KisPoint trans = event-&gt;pos() - m_dragEnd;</tt></p>
<p><tt>            m_dragStart += trans;</tt></p>
<p><tt>            m_dragEnd += trans;</tt></p>
<p><tt>        } else {</tt></p>
<p><tt>            m_dragEnd = event-&gt;pos();</tt></p>
<p><tt>        }</tt></p>
<p><tt>        // draw new lines on canvas</tt></p>
<p><tt>        draw(m_dragStart, m_dragEnd);</tt></p>
<p><tt>    }</tt></p>
<p><tt>}</tt></p>
<p>&nbsp;</p>
<p><tt>void KisToolStar::buttonRelease(KisButtonReleaseEvent *event)</tt></p>
<p><tt>{</tt></p>
<p><tt>    if (!m_subject || !m_currentImage)</tt></p>
<p><tt>        return;</tt></p>
<p>&nbsp;</p>
<p><tt>    if (m_dragging &amp;&amp; event-&gt;button() == LeftButton) {</tt></p>
<p><tt>        // erase old lines on canvas</tt></p>
<p><tt>        draw(m_dragStart, m_dragEnd);</tt></p>
<p><tt>        m_dragging = false;</tt></p>
<p>&nbsp;</p>
<p><tt>        if (m_dragStart == m_dragEnd)</tt></p>
<p><tt>            return;</tt></p>
<p>&nbsp;</p>
<p><tt>        if (!m_currentImage)</tt></p>
<p><tt>            return;</tt></p>
<p>&nbsp;</p>
<p><tt>        if (!m_currentImage-&gt;activeDevice())</tt></p>
<p><tt>            return;</tt></p>
<p>&nbsp;</p>
<p><tt>        KisPaintDeviceSP device = m_currentImage-&gt;activeDevice ();;</tt></p>
<p><tt>        KisPainter painter (device);</tt></p>
<p><tt>        if (m_currentImage-&gt;undo()) painter.beginTransaction (i18n(&quot;Star&quot;));</tt></p>
<p>&nbsp;</p>
<p><tt>        painter.setPaintColor(m_subject-&gt;fgColor());</tt></p>
<p><tt>        painter.setBackgroundColor(m_subject-&gt;bgColor());</tt></p>
<p><tt>        painter.setFillStyle(fillStyle());</tt></p>
<p><tt>        painter.setBrush(m_subject-&gt;currentBrush());</tt></p>
<p><tt>        painter.setPattern(m_subject-&gt;currentPattern());</tt></p>
<p><tt>        painter.setOpacity(m_opacity);</tt></p>
<p><tt>        painter.setCompositeOp(m_compositeOp);</tt></p>
<p><tt>        KisPaintOp * op = KisPaintOpRegistry::instance()-&gt;paintOp(m_subject-&gt;currentPaintop(), m_subject-&gt;currentPaintopSettings(), &amp;painter);</tt></p>
<p><tt>        painter.setPaintOp(op); // Painter takes ownership</tt></p>
<p>&nbsp;</p>
<p><tt>        vKisPoint coord = starCoordinates(m_vertices, m_dragStart.x(), m_dragStart.y(), m_dragEnd.x(), m_dragEnd.y());</tt></p>
<p>&nbsp;</p>
<p><tt>        painter.paintPolygon(coord);</tt></p>
<p>&nbsp;</p>
<p><tt>        device-&gt;setDirty( painter.dirtyRect() );</tt></p>
<p><tt>        notifyModified();</tt></p>
<p>&nbsp;</p>
<p><tt>        if (m_currentImage-&gt;undo()) {</tt></p>
<p><tt>            m_currentImage-&gt;undoAdapter()-&gt;addCommand(painter.endTransaction());</tt></p>
<p><tt>        }</tt></p>
<p><tt>    }</tt></p>
<p><tt>}</tt></p>
<p>The draw() method is an internal method of KisToolStar and draws the outline of the star. We call this from the move() method to give the user feedback of the size and shape of their star. Note that we use the Qt::NotROP raster operation, which means that calling draw() a second time with the same start and end point the previously drawn star will be deleted.</p>
<p><tt>void KisToolStar::draw(const KisPoint&amp; start, const KisPoint&amp; end )</tt></p>
<p><tt>{</tt></p>
<p><tt>    if (!m_subject || !m_currentImage)</tt></p>
<p><tt>        return;</tt></p>
<p>&nbsp;</p>
<p><tt>    KisCanvasController *controller = m_subject-&gt;canvasController();</tt></p>
<p><tt>    KisCanvas *canvas = controller-&gt;kiscanvas();</tt></p>
<p><tt>    KisCanvasPainter p (canvas);</tt></p>
<p><tt>    QPen pen(Qt::SolidLine);</tt></p>
<p>&nbsp;</p>
<p><tt>    KisPoint startPos;</tt></p>
<p><tt>    KisPoint endPos;</tt></p>
<p><tt>    startPos = controller-&gt;windowToView(start);</tt></p>
<p><tt>    endPos = controller-&gt;windowToView(end);</tt></p>
<p>&nbsp;</p>
<p><tt>    p.setRasterOp(Qt::NotROP);</tt></p>
<p>&nbsp;</p>
<p><tt>    vKisPoint points = starCoordinates(m_vertices, startPos.x(), startPos.y(), endPos.x(), endPos.y());</tt></p>
<p>&nbsp;</p>
<p><tt>    for (uint i = 0; i &lt; points.count() - 1; i++) {</tt></p>
<p><tt>        p.drawLine(points[i].floorQPoint(), points[i + 1].floorQPoint());</tt></p>
<p><tt>    }</tt></p>
<p><tt>    p.drawLine(points[points.count() - 1].floorQPoint(), points[0].floorQPoint());</tt></p>
<p>&nbsp;</p>
<p><tt>    p.end ();</tt></p>
<p><tt>}</tt></p>
<p>The setup() method is essential: here we create the action that will be plugged into the toolbox so users can actually select the tool. We also assign a shortcut key. Note that there’s some hackery going on: remember that we create an instance of the tool for every input device. This also means that we call setup() for every input device and that means that an action with the same name is added several times to the action collection. However, everything seems to work, so why worry?</p>
<p><tt>void KisToolStar::setup(KActionCollection *collection)</tt></p>
<p><tt>{</tt></p>
<p><tt>    m_action = static_cast&lt;KRadioAction *&gt;(collection-&gt;action(name()));</tt></p>
<p>&nbsp;</p>
<p><tt>    if (m_action == 0) {</tt></p>
<p><tt>        KShortcut shortcut(Qt::Key_Plus);</tt></p>
<p><tt>        shortcut.append(KShortcut(Qt::Key_F9));</tt></p>
<p><tt>        m_action = new KRadioAction(i18n(&quot;&amp;Star&quot;),</tt></p>
<p><tt>                                    &quot;tool_star&quot;,</tt></p>
<p><tt>                                    shortcut,</tt></p>
<p><tt>                                    this,</tt></p>
<p><tt>                                    SLOT(activate()),</tt></p>
<p><tt>                                    collection,</tt></p>
<p><tt>                                    name());</tt></p>
<p><tt>        Q_CHECK_PTR(m_action);</tt></p>
<p>&nbsp;</p>
<p><tt>        m_action-&gt;setToolTip(i18n(&quot;Draw a star&quot;));</tt></p>
<p><tt>        m_action-&gt;setExclusiveGroup(&quot;tools&quot;);</tt></p>
<p><tt>        m_ownAction = true;</tt></p>
<p><tt>    }</tt></p>
<p><tt>}</tt></p>
<p>The <tt>starCoordinates()</tt> method contains some funky math — but is not too interesting for the discussion of how to create a tool plugins. </p>
<p><tt>vKisPoint KisToolStar::starCoordinates(int N, double mx, double my, double x, double y)</tt></p>
<p><tt>{</tt></p>
<p><tt>    double R=0, r=0;</tt></p>
<p><tt>    Q_INT32 n=0;</tt></p>
<p><tt>    double angle;</tt></p>
<p>&nbsp;</p>
<p><tt>    vKisPoint starCoordinatesArray(2*N);</tt></p>
<p>&nbsp;</p>
<p><tt>    // the radius of the outer edges</tt></p>
<p><tt>    R=sqrt((x-mx)*(x-mx)+(y-my)*(y-my));</tt></p>
<p>&nbsp;</p>
<p><tt>    // the radius of the inner edges</tt></p>
<p><tt>    r=R*m_innerOuterRatio/100.0;</tt></p>
<p>&nbsp;</p>
<p><tt>    // the angle</tt></p>
<p><tt>    angle=-atan2((x-mx),(y-my));</tt></p>
<p>&nbsp;</p>
<p><tt>    //set outer edges</tt></p>
<p><tt>    for(n=0;n&lt;N;n++){</tt></p>
<p><tt>        starCoordinatesArray[2*n] = KisPoint(mx+R*cos(n * 2.0 * M_PI / N + angle),my+R*sin(n *2.0 * M_PI / N+angle));</tt></p>
<p><tt>    }</tt></p>
<p>&nbsp;</p>
<p><tt>    //set inner edges</tt></p>
<p><tt>    for(n=0;n&lt;N;n++){</tt></p>
<p><tt>        starCoordinatesArray[2*n+1] = KisPoint(mx+r*cos((n + 0.5) * 2.0 * M_PI / N + angle),my+r*sin((n +0.5) * 2.0 * M_PI / N + angle));</tt></p>
<p><tt>    }</tt></p>
<p>&nbsp;</p>
<p><tt>    return starCoordinatesArray;</tt></p>
<p><tt>}</tt></p>
<p>The <tt>createOptionWidget()</tt> method is called to create the option widget that Krita will show in the tab. Since there is a tool per input device per view, the state of a tool can be kept in the tool. This method is only called once: the option widget is stored and retrieved the next time the tool is activated.</p>
<p><tt>QWidget* KisToolStar::createOptionWidget(QWidget* parent)</tt></p>
<p><tt>{</tt></p>
<p><tt>    QWidget *widget = KisToolShape::createOptionWidget(parent);</tt></p>
<p>&nbsp;</p>
<p><tt>    m_optWidget = new WdgToolStar(widget);</tt></p>
<p><tt>    Q_CHECK_PTR(m_optWidget);</tt></p>
<p>&nbsp;</p>
<p><tt>    m_optWidget-&gt;ratioSpinBox-&gt;setValue(m_innerOuterRatio);</tt></p>
<p>&nbsp;</p>
<p><tt>    QGridLayout *optionLayout = new QGridLayout(widget, 1, 1);</tt></p>
<p><tt>    super::addOptionWidgetLayout(optionLayout);</tt></p>
<p>&nbsp;</p>
<p><tt>    optionLayout-&gt;addWidget(m_optWidget, 0, 0);</tt></p>
<p>&nbsp;</p>
<p><tt>    return widget;</tt></p>
<p><tt>}</tt></p>
<h2>Tool Conclusions</h2>
<p>Tools are relatively simple plugins to create. You need to combine the KisTool and KisCanvasObserver interfaces in order to effectively create a tool. </p>
<h1>Paint operations</h1>
<p>PaintOps are one of the more innovative types of plugins in Krita (together with pluggable colorspaces). A paint operation defines how tools change the pixels they touch. Airbrush, aliased pencil or antialiased pixel brush: these are all paint operations. But you could — with a lot of work — create a paintop that reads Corel Painter XML brush definitions and uses those to determine how painting is done.</p>
<p>Paint operations are instantiated when a paint tool receives a mouseDown event and are deleted when the mouseUp event is received by a paint tool. In between, the paintop can keep track of previous positions and other data, such as pressure levels if the user uses a tablet.</p>
<p>The basic operation of a paint operation is to change pixels at the cursor position of a paint tool. That can be done only once, or the paint op can demand to be run at regular intervals, using a timer. The first would be useful for a pencil-type paint op, the second, of course,  for an airbrush-type paintop</p>
<p>Paintops can have a small configuration widget which is placed in a toolbar. Thus, paintop configuration widgets need to have a horizontal layout of widgets that are not higher than a toolbar button. Otherwise, Krita will look very funny.</p>
<p>Let’s look at a simple paintop plugin, one that shows a little bit of programmatic intelligence. First, in the header file, there’s a factory defined. This factory creates a paintop when the active tool needs one:</p>
<p><tt>public:</tt></p>
<p><tt>    KisSmearyOpFactory() {}</tt></p>
<p><tt>    virtual ~KisSmearyOpFactory() {}</tt></p>
<p>&nbsp;</p>
<p><tt>    virtual KisPaintOp * createOp(const KisPaintOpSettings *settings, KisPainter * painter);</tt></p>
<p><tt>    virtual KisID id() { return KisID(&quot;paintSmeary&quot;, i18n(&quot;Smeary Brush&quot;)); }</tt></p>
<p><tt>    virtual bool userVisible(KisColorSpace * ) { return false; }</tt></p>
<p><tt>    virtual QString pixmap() { return &quot;&quot;; }</tt></p>
<p>&nbsp;</p>
<p><tt>};</tt></p>
<p>The factory also contains the KisID with the public and private name for the paintop — make sure your paintop’s private name does not clash with another paintop! — and may optionally return a pixmap. Krita can then show the pixmap together with the name for visual identifcation of your paintop. For instance, a painter’s knife paintop would have the image of such an implement.</p>
<p>The implementation of a paintop is very straightforward:</p>
<p><tt>KisSmearyOp::KisSmearyOp(KisPainter * painter)</tt></p>
<p><tt>    : KisPaintOp(painter)</tt></p>
<p><tt>{</tt></p>
<p><tt>}</tt></p>
<p>&nbsp;</p>
<p><tt>KisSmearyOp::~KisSmearyOp()</tt></p>
<p><tt>{</tt></p>
<p><tt>}</tt></p>
<p><tt>void KisSmearyOp::paintAt(const KisPoint &amp;pos, const KisPaintInformation&amp; info)</tt></p>
<p><tt>{</tt></p>
<p>&nbsp;</p>
<p>The <tt>paintAt() </tt>method really is where it’s at, with paintops. This method receives two parameters: the current position (which is in floats, not in whole pixels) and an <tt>KisPaintInformation</tt> object. which contains the pressure, x and y tilt, and movement vector, and may in the future be extended with other information.</p>
<p><tt>    if (!m_painter-&gt;device()) return;</tt></p>
<p>&nbsp;</p>
<p><tt>    KisBrush *brush = m_painter-&gt;brush();</tt></p>
<p>A KisBrush is the representation of a gimp brush file: that is a mask, either a single mask or a series of masks. Actually, we don’t use the brush here, except to determine the “hotspot” under the cursor.</p>
<p><tt>    Q_ASSERT(brush);</tt></p>
<p>&nbsp;</p>
<p><tt>    if (!brush) return;</tt></p>
<p>&nbsp;</p>
<p><tt>    if (! brush-&gt;canPaintFor(info) )</tt></p>
<p><tt>        return;</tt></p>
<p>&nbsp;</p>
<p><tt>    KisPaintDeviceSP device = m_painter-&gt;device();</tt></p>
<p><tt>    KisColorSpace * colorSpace = device-&gt;colorSpace();</tt></p>
<p><tt>    KisColor kc = m_painter-&gt;paintColor();</tt></p>
<p><tt>    kc.convertTo(colorSpace);</tt></p>
<p>&nbsp;</p>
<p><tt>    KisPoint hotSpot = brush-&gt;hotSpot(info);</tt></p>
<p><tt>    KisPoint pt = pos - hotSpot;</tt></p>
<p>&nbsp;</p>
<p><tt>    // Split the coordinates into integer plus fractional parts. The integer</tt></p>
<p><tt>    // is where the dab will be positioned and the fractional part determines</tt></p>
<p><tt>    // the sub-pixel positioning.</tt></p>
<p><tt>    Q_INT32 x, y;</tt></p>
<p><tt>    double xFraction, yFraction;</tt></p>
<p>&nbsp;</p>
<p><tt>    splitCoordinate(pt.x(), &amp;x, &amp;xFraction);</tt></p>
<p><tt>    splitCoordinate(pt.y(), &amp;y, &amp;yFraction);</tt></p>
<p>&nbsp;</p>
<p><tt>    KisPaintDeviceSP dab = new KisPaintDevice(colorSpace, &quot;smeary dab&quot;);</tt></p>
<p><tt>    Q_CHECK_PTR(dab);</tt></p>
<p>We don’t change the pixels of a paint device directly: instead we create a small paint device, a dab, and composite that onto the current paint device.</p>
<p><tt>    m_painter-&gt;setPressure(info.pressure);</tt></p>
<p>As the commenbts say, the next bit code does some programmatic work to create the actual dab. In this case, we draw a number of lines. When I am done with this paintop, the length, position and thickness of the lines will be dependent on pressure and paint load, and we’ll have create a stiff, smeary oilpaint brush. But I havne’t had time to finish this yet.</p>
<p><tt>    // Compute the position of the tufts. The tufts are arranged in a line</tt></p>
<p><tt>    // perpendicular to the motion of the brush, i.e, the straight line between</tt></p>
<p><tt>    // the current position and the previous position.</tt></p>
<p><tt>    // The tufts are spread out through the pressure</tt></p>
<p>&nbsp;</p>
<p><tt>    KisPoint previousPoint = info.movement.toKisPoint();</tt></p>
<p><tt>    KisVector2D brushVector(-previousPoint.y(), previousPoint.x());</tt></p>
<p><tt>    KisVector2D currentPointVector = KisVector2D(pos);</tt></p>
<p><tt>    brushVector.normalize();</tt></p>
<p>&nbsp;</p>
<p><tt>    KisVector2D vl, vr;</tt></p>
<p>&nbsp;</p>
<p><tt>    for (int i = 0; i &lt; (NUMBER_OF_TUFTS / 2); ++i) {</tt></p>
<p><tt>        // Compute the positions on the new vector.</tt></p>
<p><tt>        vl = currentPointVector + i * brushVector;</tt></p>
<p><tt>        KisPoint pl = vl.toKisPoint();</tt></p>
<p><tt>        dab-&gt;setPixel(pl.roundX(), pl.roundY(), kc);</tt></p>
<p>&nbsp;</p>
<p><tt>        vr = currentPointVector - i * brushVector;</tt></p>
<p><tt>        KisPoint pr = vr.toKisPoint();</tt></p>
<p><tt>        dab-&gt;setPixel(pr.roundX(), pr.roundY(), kc);</tt></p>
<p><tt>    }</tt></p>
<p>&nbsp;</p>
<p><tt>    vr = vr - vl;</tt></p>
<p><tt>    vr.normalize();</tt></p>
<p>Finally we blt the dab onto the original paint device and tell the painter that we’ve dirtied a small rectangle of the paint device.  </p>
<p><tt>    if (m_source-&gt;hasSelection()) {</tt></p>
<p><tt>        m_painter-&gt;bltSelection(x - 32, y - 32, m_painter-&gt;compositeOp(), dab.data(),</tt></p>
<p><tt>                                m_source-&gt;selection(), m_painter-&gt;opacity(), x - 32, y -32, 64, 64);</tt></p>
<p><tt>    }</tt></p>
<p><tt>    else {</tt></p>
<p><tt>        m_painter-&gt;bitBlt(x - 32, y - 32, m_painter-&gt;compositeOp(), dab.data(), m_painter-&gt;opacity(), x - 32, y -32, 64, 64);</tt></p>
<p><tt>    }</tt></p>
<p>&nbsp;</p>
<p><tt>    m_painter-&gt;addDirtyRect(QRect(x -32, y -32, 64, 64));</tt></p>
<p><tt>}</tt></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p><tt>KisPaintOp * KisSmearyOpFactory::createOp(const KisPaintOpSettings */*settings*/, KisPainter * painter)</tt></p>
<p><tt>{</tt></p>
<p><tt>    KisPaintOp * op = new KisSmearyOp(painter);</tt></p>
<p><tt>    Q_CHECK_PTR(op);</tt></p>
<p><tt>    return op;</tt></p>
<p><tt>}</tt></p>
<p>That’s all: paintops are easy and fun!</p>
<h1>Viewplugins</h1>
<p>View plugins are the weirdest of the bunch: a view plugin is an ordinary KPart that can provide a bit of user interface and some functionality. For instance, the histogram tab is a view plugin, as is the rotate dialog.</p>
<p>&nbsp;</p>
<h1>Import/Export filters</h1>
<p>Krita works with the ordinary KOffice file filter architecture. There's an tutorial, a bit old, but still useful, at: http://koffice.org/developer/filters/oldfaq.php. It is probably best to cooperate with the krita team when developing file filters and do the development in the koffice filter tree. Note that you can test your filters without running Krita using the <b>koconverter</b> utility.</p>
<p>Filters have two sides: importing and exporting. These are usually two different plugins that may share some code.</p>
<p>The important Makefile.am entries are:</p>
<p><tt>service_DATA = krita_XXX_import.desktop krita_XXX_export.desktop</tt></p>
<p><tt>servicedir = $(kde_servicesdir)</tt></p>
<p><tt>kdelnk_DATA = krita_XXX.desktop</tt></p>
<p><tt>kdelnkdir = $(kde_appsdir)/Office</tt></p>
<p><tt>libkritaXXXimport_la_SOURCES = XXXimport.cpp</tt></p>
<p><tt>libkritaXXXexport_la_SOURCES = XXXexport.cpp</tt></p>
<p><tt>METASOURCES = AUTO</tt></p>
<p>Whether you're building an import filter or an export filter, your work always boils down to implementing the following funtion:</p>
<p><tt>virtual KoFilter::ConversionStatus convert(const QCString&amp; from, const QCString&amp; to);</tt></p>
<p>It's the settings in the .desktop files that determine which way a filter converts:</p>
<p>Import:</p>
<p><tt>X-KDE-Export=application/x-krita</tt></p>
<p><tt>X-KDE-Import=image/x-xcf-gimp</tt></p>
<p><tt>X-KDE-Weight=1</tt></p>
<p><tt>X-KDE-Library=libkritaXXXimport</tt></p>
<p><tt>ServiceTypes=KOfficeFilter</tt></p>
<p>Export:</p>
<p><tt>X-KDE-Export=image/x-xcf-gimp</tt></p>
<p><tt>X-KDE-Import=application/x-krita</tt></p>
<p><tt>ServiceTypes=KOfficeFilter</tt></p>
<p><tt>Type=Service</tt></p>
<p><tt>X-KDE-Weight=1</tt></p>
<p><tt>X-KDE-Library=libkritaXXXexport</tt></p>
<p>And yes, the mimetype chosen for the example <i>is</i> a hint. Please, pretty please, implement an xcf filter?</p>
<h2>Import</h2>
<p>The big problem with import filters is of course your code to read the data on disk. The boilerplate for calling that code is fairly simple2:</p>
<p><tt>KoFilter::ConversionStatus XXXImport::convert(const QCString&amp;, const QCString&amp; to)</tt></p>
<p><tt>{</tt></p>
<p><tt>    if (to != &quot;application/x-krita&quot;) <b>(1)</b></tt></p>
<p><tt>        return KoFilter::BadMimeType;</tt></p>
<p><tt>&nbsp;</tt></p>
<p><tt>    KisDoc * doc = dynamic_cast&lt;KisDoc*&gt;(m_chain -&gt; outputDocument()); <b>(2)</b></tt></p>
<p><tt>    KisView * view = static_cast&lt;KisView*&gt;(doc -&gt; views().getFirst()); <b>(3)</b></tt></p>
<p><tt>&nbsp;</tt></p>
<p><tt>    QString filename = m_chain -&gt; inputFile(); <b>(4)</b></tt></p>
<p><tt>&nbsp;</tt></p>
<p><tt>    if (!doc)</tt></p>
<p><tt>        return KoFilter::CreationError;</tt></p>
<p><tt>&nbsp;</tt></p>
<p><tt>    doc -&gt; prepareForImport(); <b>(5)</b></tt></p>
<p><tt>&nbsp;</tt></p>
<p><tt>    if (!filename.isEmpty()) {</tt></p>
<p><tt>&nbsp;</tt></p>
<p><tt>        KURL url(filename);</tt></p>
<p><tt>&nbsp;</tt></p>
<p><tt>        if (url.isEmpty())</tt></p>
<p><tt>            return KoFilter::FileNotFound;</tt></p>
<p><tt>&nbsp;</tt></p>
<p><tt>        KisImageXXXConverter ib(doc, doc -&gt; undoAdapter());<b>(6)</b></tt></p>
<p><tt>&nbsp;</tt></p>
<p><tt>        if (view != 0)</tt></p>
<p><tt>            view -&gt; canvasSubject() -&gt;  progressDisplay() -&gt; setSubject(&amp;ib, false, true);</tt></p>
<p><tt>&nbsp;</tt></p>
<p><tt>        switch (ib.buildImage(url)) <b>(7)</b>{</tt></p>
<p><tt>            case KisImageBuilder_RESULT_UNSUPPORTED:</tt></p>
<p><tt>                return KoFilter::NotImplemented;</tt></p>
<p><tt>                break;</tt></p>
<p><tt>            case KisImageBuilder_RESULT_INVALID_ARG:</tt></p>
<p><tt>                return KoFilter::BadMimeType;</tt></p>
<p><tt>                break;</tt></p>
<p><tt>            case KisImageBuilder_RESULT_NO_URI:</tt></p>
<p><tt>            case KisImageBuilder_RESULT_NOT_LOCAL:</tt></p>
<p><tt>                return KoFilter::FileNotFound;</tt></p>
<p><tt>                break;</tt></p>
<p><tt>            case KisImageBuilder_RESULT_BAD_FETCH:</tt></p>
<p><tt>            case KisImageBuilder_RESULT_EMPTY:</tt></p>
<p><tt>                return KoFilter::ParsingError;                </tt></p>
<p><tt>                break;</tt></p>
<p><tt>            case KisImageBuilder_RESULT_FAILURE:</tt></p>
<p><tt>                return KoFilter::InternalError;</tt></p>
<p><tt>                break;</tt></p>
<p><tt>            case KisImageBuilder_RESULT_OK:</tt></p>
<p><tt>                doc -&gt; setCurrentImage( ib.image()); <b>(8)</b></tt></p>
<p><tt>                return KoFilter::OK;</tt></p>
<p><tt>            default:</tt></p>
<p><tt>                break;</tt></p>
<p><tt>        }</tt></p>
<p><tt>&nbsp;</tt></p>
<p><tt>    }</tt></p>
<p><tt>    return KoFilter::StorageCreationError;</tt></p>
<p><tt>}</tt></p>
<p><b>(1) </b>This is supposed to be an importfilter, so if it's not called to convert to a krita image, then something is wrong.</p>
<p><b>(2) </b>The filter chain already has created an output document for us. We need to cast it to <b>KisDoc</b>, because Krita documents need special treatment. It wouldn't, actually, be all that bad an idea to check whether the result of the cast is not <b>0</b>, because if it is, importing will fail.</p>
<p><b>(3) </b>If we call this filter from the GUI, we try to get the view. If there's a view, the conversion code can try to update the progressbar.</p>
<p><b>(4) </b>The filter has the filename for our input file for us.</p>
<p><b>(5)</b> KisDoc needs to be prepared for import. Certain settings are initialized and undo is disabled. Otherwise you could undo the adding of layers performed by the import filter and that's weird behaviour.</p>
<p><b>(6)</b> I have chosed to implement the actual importing code in a separate class that I instantiate here. You can also put all your code right in this method, but that would be a bit messy.</p>
<p><b>(7)</b> My importer returns a statuscode that I can then use to set the status of the import filter. KOffice takes care of showing error messages.</p>
<p><b>(8)</b> If creating the KisImage has succeeded we set the document's current image to our newly created image. Then then we're done: <b>return KoFilter::OK;</b>.</p>
<p>Export</p>
</body>
</html>
